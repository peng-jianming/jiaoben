<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端计算机视觉：OpenCV.js 图像处理演示</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        /* 样式保持不变 */
        .canvas-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        canvas {
            border: 1px solid #ccc;
            max-width: 100%;
            height: auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .processing-btn {
            margin: 5px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .processing-btn:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .processing-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .slider-container {
            margin: 15px 0;
            padding: 10px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .slider-value {
            font-weight: bold;
            color: #007bff;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #e9ecef;
            outline: none;
        }

        .tab-container {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #dee2e6;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab.active {
            border-bottom-color: #007bff;
            color: #007bff;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .status-processing {
            background-color: #fff3cd;
            color: #856404;
        }

        .status-success {
            background-color: #d1ecf1;
            color: #0c5460;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .download-btn {
            background-color: #28a745;
        }
        
        .download-btn:hover {
            background-color: #218838;
        }
        
        .crop-btn {
            background-color: #ffc107;
            color: #212529;
        }
        
        .crop-btn:hover {
            background-color: #e0a800;
        }
        
        .selection-overlay {
            position: absolute;
            border: 2px dashed #ff0000;
            background-color: rgba(255, 255, 255, 0.2);
            pointer-events: none;
            display: none;
        }
        
        .crop-controls {
            margin-top: 15px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 6px;
        }
        
        .crop-info {
            margin-top: 10px;
            padding: 10px;
            background: #d1ecf1;
            border-radius: 4px;
        }
        
        .match-controls {
            margin-top: 15px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 6px;
        }
        
        .match-btn {
            background-color: #6f42c1;
            color: white;
        }
        
        .match-btn:hover {
            background-color: #5a32a3;
        }
        
        .match-result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        
        .match-success {
            background-color: #d4edda;
            color: #155724;
        }
        
        .match-failure {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .match-rectangle {
            position: absolute;
            border: 2px solid #ff0000;
            background-color: rgba(255, 0, 0, 0.1);
            pointer-events: none;
        }
        
        .large-image-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>

<body class="bg-gray-50">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">
            <i class="fas fa-eye mr-2"></i>前端计算机视觉：OpenCV.js 图像处理演示
        </h1>

        <div id="status" class="text-center mb-4 p-4 bg-blue-100 text-blue-800 rounded">
            正在加载 OpenCV.js...
        </div>

        <!-- 标签页导航 -->
        <div class="tab-container">
            <div class="tab active" onclick="switchTab('image-processing')">图像处理</div>
            <div class="tab" onclick="switchTab('image-matching')">图像匹配</div>
        </div>

        <!-- 图像处理部分 -->
        <div id="image-processing" class="tab-content active bg-white rounded-lg shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-gray-700">
                <i class="fas fa-image mr-2"></i>图像处理
            </h2>

            <div class="mb-4">
                <input type="file" id="imageInput" accept="image/*"
                    class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
            </div>

            <div class="control-panel">
                <h3 class="text-lg font-semibold mb-3">处理选项</h3>
                <div class="flex flex-wrap gap-2">
                    <button class="processing-btn" onclick="convertToGray()">灰度转换</button>
                    <button class="processing-btn" onclick="applyCanny()">Canny边缘检测</button>
                    <button class="processing-btn" onclick="applyThreshold()">阈值分割</button>
                    <button class="processing-btn" onclick="applyBinaryThreshold()">二值化(OTSU)</button>
                    <button class="processing-btn" onclick="detectContours()">轮廓检测</button>
                    <button class="processing-btn crop-btn" onclick="startCrop()">裁剪图像</button>
                    <button class="processing-btn download-btn" onclick="downloadImage()">下载处理结果</button>
                    <button class="processing-btn" onclick="resetImage()">重置图像</button>
                </div>

                <!-- 二值化阈值控制面板 -->
                <div id="threshold-control" class="slider-container">
                    <div class="slider-label">
                        <span>二值化阈值</span>
                        <span id="threshold-value" class="slider-value">127</span>
                    </div>
                    <input type="range" id="threshold-slider" min="0" max="255" value="127" oninput="updateThresholdValue(this.value)">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>0</span>
                        <span>255</span>
                    </div>
                    <button class="processing-btn mt-2" onclick="applyManualThreshold()">应用手动二值化</button>
                </div>
                
                <!-- 裁剪控制面板 -->
                <div id="crop-controls" class="crop-controls" style="display: none;">
                    <h4 class="font-semibold mb-2">裁剪控制</h4>
                    <p class="text-sm mb-2">在原始图像上拖动鼠标选择裁剪区域</p>
                    <div class="flex gap-2">
                        <button class="processing-btn" onclick="applyCrop()">应用裁剪</button>
                        <button class="processing-btn" onclick="cancelCrop()">取消裁剪</button>
                    </div>
                    <div id="crop-info" class="crop-info">
                        <p>选择区域: <span id="crop-coords">未选择</span></p>
                    </div>
                </div>
            </div>

            <div class="canvas-container mt-4">
                <div class="relative">
                    <p class="text-center font-semibold mb-2">原始图像</p>
                    <div class="relative inline-block">
                        <canvas id="inputCanvas"></canvas>
                        <div id="selectionOverlay" class="selection-overlay"></div>
                    </div>
                </div>
                <div>
                    <p class="text-center font-semibold mb-2">处理后图像</p>
                    <div class="feature-container">
                        <canvas id="outputCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- 图像匹配部分 -->
        <div id="image-matching" class="tab-content bg-white rounded-lg shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-gray-700">
                <i class="fas fa-search mr-2"></i>图像匹配
            </h2>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">上传大图 (aPath)</label>
                <input type="file" id="largeImageInput" accept="image/*"
                    class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                
                <div class="large-image-controls">
                    <button class="processing-btn" onclick="useProcessedAsLargeImage()">使用处理后的图像作为大图</button>
                </div>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">上传小图 (bPaths) - 可多选</label>
                <input type="file" id="smallImageInput" accept="image/*" multiple
                    class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                
                <div class="large-image-controls">
                    <button class="processing-btn" onclick="useProcessedAsTemplate()">使用处理后的图像作为小图</button>
                </div>
            </div>

            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">匹配阈值</label>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>阈值</span>
                        <span id="match-threshold-value" class="slider-value">0.8</span>
                    </div>
                    <input type="range" id="match-threshold-slider" min="0" max="1" step="0.01" value="0.8" oninput="updateMatchThresholdValue(this.value)">
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>0</span>
                        <span>1</span>
                    </div>
                </div>
            </div>

            <div class="match-controls">
                <div class="flex gap-2">
                    <button class="processing-btn match-btn" onclick="startMatching()">开始匹配</button>
                </div>
                
                <div id="match-result" class="match-result">
                    <p id="match-result-text"></p>
                </div>
            </div>

            <div class="canvas-container mt-4">
                <div class="relative">
                    <p class="text-center font-semibold mb-2">大图</p>
                    <div class="relative inline-block">
                        <canvas id="largeImageCanvas"></canvas>
                        <div id="matchRectangle" class="match-rectangle" style="display: none;"></div>
                    </div>
                </div>
                <div>
                    <p class="text-center font-semibold mb-2">小图</p>
                    <div id="smallImagesContainer" class="flex flex-wrap gap-4 justify-center">
                        <!-- 小图将在这里显示 -->
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        let src, dst, currentProcessed, originalSrc;
        let inputCanvas, outputCanvas;
        let thresholdValue = 127;
        let isImageLoaded = false;
        
        // 裁剪相关变量
        let isCropping = false;
        let cropStartX, cropStartY, cropEndX, cropEndY;
        let selectionOverlay;
        let hasBeenCropped = false;
        let croppedImage = null;

        // 匹配相关变量
        let largeImageCanvas, smallImagesContainer, matchRectangle;
        let matchThresholdValue = 0.8;
        let largeImageMat = null;
        let smallImageMats = [];

        function onOpenCvReady() {
            document.getElementById('status').innerHTML = 'OpenCV.js 已加载完成 ✓';
            document.getElementById('status').classList.remove('bg-blue-100', 'text-blue-800');
            document.getElementById('status').classList.add('status-success');
            initializeElements();
            setupImageInput();
            setupMatchingInputs();
        }

        function initializeElements() {
            inputCanvas = document.getElementById('inputCanvas');
            outputCanvas = document.getElementById('outputCanvas');
            selectionOverlay = document.getElementById('selectionOverlay');
            
            // 匹配相关元素
            largeImageCanvas = document.getElementById('largeImageCanvas');
            smallImagesContainer = document.getElementById('smallImagesContainer');
            matchRectangle = document.getElementById('matchRectangle');
        }

        function setupImageInput() {
            const imageInput = document.getElementById('imageInput');
            imageInput.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const img = new Image();
                        img.onload = function () {
                            loadImageToCanvas(img);
                        };
                        img.src = reader.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function setupMatchingInputs() {
            // 大图上传
            const largeImageInput = document.getElementById('largeImageInput');
            largeImageInput.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const img = new Image();
                        img.onload = function () {
                            loadLargeImage(img);
                        };
                        img.src = reader.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            // 小图上传
            const smallImageInput = document.getElementById('smallImageInput');
            smallImageInput.addEventListener('change', function (e) {
                const files = e.target.files;
                smallImageMats = [];
                smallImagesContainer.innerHTML = '';
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    reader.onload = function (event) {
                        const img = new Image();
                        img.onload = function () {
                            loadSmallImage(img, i);
                        };
                        img.src = reader.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function loadImageToCanvas(img) {
            inputCanvas.width = img.width;
            inputCanvas.height = img.height;
            outputCanvas.width = img.width;
            outputCanvas.height = img.height;

            src = cv.imread(img);
            originalSrc = src.clone();
            currentProcessed = src.clone();
            dst = new cv.Mat();

            cv.imshow(inputCanvas, src);
            src.copyTo(dst);
            cv.imshow(outputCanvas, dst);
            
            isImageLoaded = true;
            hasBeenCropped = false;
            croppedImage = null;
            
            // 重置裁剪状态
            cancelCrop();
        }

        function loadLargeImage(img) {
            largeImageCanvas.width = img.width;
            largeImageCanvas.height = img.height;
            
            // 创建OpenCV Mat对象
            if (largeImageMat) largeImageMat.delete();
            largeImageMat = cv.imread(img);
            cv.imshow(largeImageCanvas, largeImageMat);
            
            // 隐藏匹配矩形
            matchRectangle.style.display = 'none';
            
            // 清除匹配结果
            document.getElementById('match-result').style.display = 'none';
        }

        function loadSmallImage(img, index) {
            // 创建canvas显示小图
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            canvas.className = 'border border-gray-300';
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            // 添加到容器
            const container = document.createElement('div');
            container.className = 'text-center';
            container.innerHTML = `<p class="text-sm mb-1">小图 ${index + 1}</p>`;
            container.appendChild(canvas);
            smallImagesContainer.appendChild(container);
            
            // 创建OpenCV Mat对象并保存
            const mat = cv.imread(img);
            smallImageMats.push(mat);
            
            // 清除匹配结果
            document.getElementById('match-result').style.display = 'none';
        }

        // 标签页切换功能
        function switchTab(tabName) {
            // 隐藏所有标签内容
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 移除所有标签的激活状态
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示选中的标签内容
            document.getElementById(tabName).classList.add('active');
            
            // 激活选中的标签
            event.target.classList.add('active');
        }

        // 更新阈值显示
        function updateThresholdValue(value) {
            thresholdValue = parseInt(value);
            document.getElementById('threshold-value').textContent = value;
        }

        // 更新匹配阈值显示
        function updateMatchThresholdValue(value) {
            matchThresholdValue = parseFloat(value);
            document.getElementById('match-threshold-value').textContent = value.toFixed(2);
        }

        // 统一的处理函数，确保每个功能都在当前处理结果上进行
        function applyProcessing(processingFunction) {
            if (!isImageLoaded || !currentProcessed) {
                alert('请先上传图像');
                return;
            }
            
            // 使用当前处理结果作为输入
            processingFunction(currentProcessed, dst);
            
            // 将处理结果复制到currentProcessed，以便下一次处理
            dst.copyTo(currentProcessed);
            
            // 显示处理后的图像
            cv.imshow(outputCanvas, currentProcessed);
        }

        function convertToGray() {
            applyProcessing((input, output) => {
                cv.cvtColor(input, output, cv.COLOR_RGB2GRAY);
                cv.cvtColor(output, output, cv.COLOR_GRAY2RGB);
            });
        }

        function applyCanny() {
            applyProcessing((input, output) => {
                let gray = new cv.Mat();
                cv.cvtColor(input, gray, cv.COLOR_RGB2GRAY);
                cv.Canny(gray, output, 100, 200, 3, false);
                cv.cvtColor(output, output, cv.COLOR_GRAY2RGB);
                gray.delete();
            });
        }

        function applyThreshold() {
            applyProcessing((input, output) => {
                let gray = new cv.Mat();
                cv.cvtColor(input, gray, cv.COLOR_RGB2GRAY);
                cv.threshold(gray, output, 127, 255, cv.THRESH_BINARY);
                cv.cvtColor(output, output, cv.COLOR_GRAY2RGB);
                gray.delete();
            });
        }

        // 新增的二值化功能（OTSU方法）
        function applyBinaryThreshold() {
            applyProcessing((input, output) => {
                let gray = new cv.Mat();
                cv.cvtColor(input, gray, cv.COLOR_RGB2GRAY);
                // 使用OTSU方法自动计算阈值
                cv.threshold(gray, output, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
                cv.cvtColor(output, output, cv.COLOR_GRAY2RGB);
                gray.delete();
            });
        }

        // 手动调整阈值的二值化 - 每次都在原始图像上进行
        function applyManualThreshold() {
            if (!isImageLoaded || !originalSrc) {
                alert('请先上传图像');
                return;
            }
            
            // 使用原始图像而不是当前处理结果
            let gray = new cv.Mat();
            let tempDst = new cv.Mat();
            
            cv.cvtColor(originalSrc, gray, cv.COLOR_RGB2GRAY);
            cv.threshold(gray, tempDst, thresholdValue, 255, cv.THRESH_BINARY);
            cv.cvtColor(tempDst, tempDst, cv.COLOR_GRAY2RGB);
            
            // 更新当前处理结果
            if (currentProcessed) currentProcessed.delete();
            currentProcessed = tempDst.clone();
            
            // 显示处理后的图像
            cv.imshow(outputCanvas, currentProcessed);
            
            // 清理内存
            gray.delete();
            tempDst.delete();
        }

        function detectContours() {
            applyProcessing((input, output) => {
                let gray = new cv.Mat();
                let thresh = new cv.Mat();
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();

                cv.cvtColor(input, gray, cv.COLOR_RGB2GRAY);
                cv.threshold(gray, thresh, 127, 255, cv.THRESH_BINARY);
                cv.findContours(thresh, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);

                input.copyTo(output);
                for (let i = 0; i < contours.size(); i++) {
                    let color = new cv.Scalar(Math.random() * 255, Math.random() * 255, Math.random() * 255);
                    cv.drawContours(output, contours, i, color, 2);
                }

                gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
            });
        }

        // 裁剪相关函数保持不变...
        // 开始裁剪模式
        function startCrop() {
            if (!isImageLoaded || !originalSrc) {
                alert('请先上传图像');
                return;
            }
            
            isCropping = true;
            document.getElementById('crop-controls').style.display = 'block';
            
            // 重置选择区域
            cropStartX = cropStartY = cropEndX = cropEndY = 0;
            updateSelectionOverlay();
            
            // 添加鼠标事件监听
            inputCanvas.addEventListener('mousedown', startSelection);
            inputCanvas.style.cursor = 'crosshair';
            
            document.getElementById('status').innerHTML = '裁剪模式：请在原始图像上拖动鼠标选择区域';
            document.getElementById('status').classList.remove('status-success');
            document.getElementById('status').classList.add('status-processing');
        }

        // 开始选择区域
        function startSelection(e) {
            if (!isCropping) return;
            
            const rect = inputCanvas.getBoundingClientRect();
            const scaleX = inputCanvas.width / rect.width;
            const scaleY = inputCanvas.height / rect.height;
            
            cropStartX = (e.clientX - rect.left) * scaleX;
            cropStartY = (e.clientY - rect.top) * scaleY;
            
            document.addEventListener('mousemove', updateSelection);
            document.addEventListener('mouseup', endSelection);
        }

        // 更新选择区域
        function updateSelection(e) {
            if (!isCropping) return;
            
            const rect = inputCanvas.getBoundingClientRect();
            const scaleX = inputCanvas.width / rect.width;
            const scaleY = inputCanvas.height / rect.height;
            
            cropEndX = (e.clientX - rect.left) * scaleX;
            cropEndY = (e.clientY - rect.top) * scaleY;
            
            updateSelectionOverlay();
        }

        // 结束选择区域
        function endSelection() {
            document.removeEventListener('mousemove', updateSelection);
            document.removeEventListener('mouseup', endSelection);
            
            // 确保坐标正确（起点在左上，终点在右下）
            const x = Math.min(cropStartX, cropEndX);
            const y = Math.min(cropStartY, cropEndY);
            const width = Math.abs(cropEndX - cropStartX);
            const height = Math.abs(cropEndY - cropStartY);
            
            document.getElementById('crop-coords').textContent = 
                `X: ${Math.round(x)}, Y: ${Math.round(y)}, 宽度: ${Math.round(width)}, 高度: ${Math.round(height)}`;
        }

        // 更新选择区域覆盖层
        function updateSelectionOverlay() {
            const x = Math.min(cropStartX, cropEndX);
            const y = Math.min(cropStartY, cropEndY);
            const width = Math.abs(cropEndX - cropStartX);
            const height = Math.abs(cropEndY - cropStartY);
            
            selectionOverlay.style.left = x + 'px';
            selectionOverlay.style.top = y + 'px';
            selectionOverlay.style.width = width + 'px';
            selectionOverlay.style.height = height + 'px';
            selectionOverlay.style.display = 'block';
        }

        // 应用裁剪
        function applyCrop() {
            if (!isCropping) return;
            
            const x = Math.min(cropStartX, cropEndX);
            const y = Math.min(cropStartY, cropEndY);
            const width = Math.abs(cropEndX - cropStartX);
            const height = Math.abs(cropEndY - cropStartY);
            
            // 确保选择区域有效
            if (width <= 0 || height <= 0) {
                alert('请选择一个有效的区域进行裁剪');
                return;
            }
            
            // 使用原始图像进行裁剪
            const rect = new cv.Rect(x, y, width, height);
            const cropped = originalSrc.roi(rect);
            
            // 保存裁剪后的图像
            if (croppedImage) croppedImage.delete();
            croppedImage = cropped.clone();
            
            // 更新当前处理图像
            if (currentProcessed) currentProcessed.delete();
            currentProcessed = croppedImage.clone();
            
            // 更新输出Canvas尺寸
            outputCanvas.width = width;
            outputCanvas.height = height;
            
            // 显示裁剪后的图像
            cv.imshow(outputCanvas, currentProcessed);
            
            // 设置裁剪标记
            hasBeenCropped = true;
            
            // 退出裁剪模式
            cancelCrop();
            
            document.getElementById('status').innerHTML = '裁剪完成 ✓';
            document.getElementById('status').classList.remove('status-processing');
            document.getElementById('status').classList.add('status-success');
            
            // 清理内存
            cropped.delete();
        }

        // 取消裁剪
        function cancelCrop() {
            isCropping = false;
            document.getElementById('crop-controls').style.display = 'none';
            selectionOverlay.style.display = 'none';
            inputCanvas.style.cursor = 'default';
            
            // 移除事件监听
            inputCanvas.removeEventListener('mousedown', startSelection);
            document.removeEventListener('mousemove', updateSelection);
            document.removeEventListener('mouseup', endSelection);
            
            if (isImageLoaded) {
                document.getElementById('status').innerHTML = 'OpenCV.js 已加载完成 ✓';
                document.getElementById('status').classList.remove('status-processing');
                document.getElementById('status').classList.add('status-success');
            }
        }

        // 下载处理后的图像
        function downloadImage() {
            if (!isImageLoaded || !currentProcessed) {
                alert('请先上传并处理图像');
                return;
            }
            
            // 创建一个临时的canvas来导出图像
            const downloadCanvas = document.createElement('canvas');
            downloadCanvas.width = outputCanvas.width;
            downloadCanvas.height = outputCanvas.height;
            const ctx = downloadCanvas.getContext('2d');
            
            // 绘制当前处理后的图像
            cv.imshow(downloadCanvas, currentProcessed);
            
            // 创建下载链接
            const link = document.createElement('a');
            link.download = 'processed_image.png';
            link.href = downloadCanvas.toDataURL('image/png');
            link.click();
        }

        function resetImage() {
            if (!isImageLoaded || !originalSrc) return;
            
            // 重置图像只重置处理效果，不重置裁剪
            if (hasBeenCropped && croppedImage) {
                // 如果图像已被裁剪，重置到裁剪后的图像
                if (currentProcessed) currentProcessed.delete();
                currentProcessed = croppedImage.clone();
                
                // 确保输出Canvas尺寸正确
                outputCanvas.width = croppedImage.cols;
                outputCanvas.height = croppedImage.rows;
                
                cv.imshow(outputCanvas, currentProcessed);
            } else {
                // 如果图像未被裁剪，重置到原始图像
                if (currentProcessed) currentProcessed.delete();
                currentProcessed = originalSrc.clone();
                
                // 重置Canvas尺寸
                outputCanvas.width = inputCanvas.width;
                outputCanvas.height = inputCanvas.height;
                
                cv.imshow(outputCanvas, currentProcessed);
            }
            
            cancelCrop();
        }

        // 使用处理后的图像作为大图
        function useProcessedAsLargeImage() {
            if (!isImageLoaded || !currentProcessed) {
                alert('请先上传并处理图像');
                return;
            }
            
            // 更新大图Canvas尺寸
            largeImageCanvas.width = currentProcessed.cols;
            largeImageCanvas.height = currentProcessed.rows;
            
            // 更新大图Mat对象
            if (largeImageMat) largeImageMat.delete();
            largeImageMat = currentProcessed.clone();
            
            // 显示大图
            cv.imshow(largeImageCanvas, largeImageMat);
            
            // 隐藏匹配矩形
            matchRectangle.style.display = 'none';
            
            // 清除匹配结果
            document.getElementById('match-result').style.display = 'none';
        }

        // 使用处理后的图像作为小图
        function useProcessedAsTemplate() {
            if (!isImageLoaded || !currentProcessed) {
                alert('请先上传并处理图像');
                return;
            }
            
            // 清空之前的小图
            smallImageMats.forEach(mat => {
                if (mat) mat.delete();
            });
            smallImageMats = [];
            smallImagesContainer.innerHTML = '';
            
            // 创建canvas显示处理后的图像
            const canvas = document.createElement('canvas');
            canvas.width = currentProcessed.cols;
            canvas.height = currentProcessed.rows;
            canvas.className = 'border border-gray-300';
            
            cv.imshow(canvas, currentProcessed);
            
            // 添加到容器
            const container = document.createElement('div');
            container.className = 'text-center';
            container.innerHTML = `<p class="text-sm mb-1">处理后的图像</p>`;
            container.appendChild(canvas);
            smallImagesContainer.appendChild(container);
            
            // 保存为小图Mat对象
            const mat = currentProcessed.clone();
            smallImageMats.push(mat);
            
            // 清除匹配结果
            document.getElementById('match-result').style.display = 'none';
        }

        // 开始匹配
        async function startMatching() {
            if (!largeImageMat || smallImageMats.length === 0) {
                alert('请先上传大图和小图');
                return;
            }
            
            // 显示匹配中状态
            document.getElementById('match-result').style.display = 'block';
            document.getElementById('match-result').className = 'match-result status-processing';
            document.getElementById('match-result-text').textContent = '正在匹配中...';
            
            // 隐藏之前的匹配矩形
            matchRectangle.style.display = 'none';
            
            try {
                // 调用findPic函数进行匹配
                const result = await findPic(largeImageMat, smallImageMats, matchThresholdValue);
                
                // 显示匹配结果
                const matchResult = document.getElementById('match-result');
                const matchResultText = document.getElementById('match-result-text');
                
                if (result.found) {
                    matchResult.className = 'match-result match-success';
                    matchResultText.textContent = `匹配成功！置信度: ${result.confidence.toFixed(4)}，位置: (${result.location.x}, ${result.location.y})`;
                    
                    // 显示匹配矩形
                    showMatchRectangle(result.location);
                } else {
                    matchResult.className = 'match-result match-failure';
                    matchResultText.textContent = `匹配失败！最高置信度: ${result.confidence.toFixed(4)}`;
                }
            } catch (error) {
                console.error('匹配过程中出错:', error);
                document.getElementById('match-result').className = 'match-result status-error';
                document.getElementById('match-result-text').textContent = '匹配过程中出错: ' + error.message;
            }
        }

        // 显示匹配矩形
        function showMatchRectangle(location) {
            matchRectangle.style.left = location.x + 'px';
            matchRectangle.style.top = location.y + 'px';
            matchRectangle.style.width = location.width + 'px';
            matchRectangle.style.height = location.height + 'px';
            matchRectangle.style.display = 'block';
        }

 // 图像匹配函数
 async function findPic(aMat, bMats, threshold = 0.8) {
            const templateMats = Array.isArray(bMats) ? bMats : [bMats];

            try {
                const srcMat = aMat;
                const srcGray = new cv.Mat();
                cv.cvtColor(srcMat, srcGray, cv.COLOR_RGBA2GRAY);

                let bestResult = {
                    found: false,
                    confidence: 0,
                    location: null,
                    index: -1,
                };

                for (let i = 0; i < templateMats.length; i++) {
                    const templMat = templateMats[i];
                    let templGray = null;
                    let mask = null;

                    try {
                        templGray = new cv.Mat();
                        cv.cvtColor(templMat, templGray, cv.COLOR_RGBA2GRAY);

                        // 检查图像尺寸，避免模板图比原图大
                        if (templGray.rows > srcGray.rows || templGray.cols > srcGray.cols) {
                            console.warn(`模板图片 ${i} 尺寸大于原图，跳过匹配`);
                            continue;
                        }



                        const result = new cv.Mat();
                        const method = cv.TM_CCOEFF_NORMED;

                        cv.matchTemplate(srcGray, templGray, result, method);

                        const minMax = cv.minMaxLoc(result);
                        let maxValue = minMax.maxVal;
                        const maxLoc = minMax.maxLoc;

                        // 关键修复：检查并处理异常数值
                        if (!isFinite(maxValue)) {
                            console.warn(`检测到异常匹配值: ${maxValue}，将其设置为0`);
                            maxValue = 0;
                        }

                        // 确保匹配值在合理范围内 [0, 1]
                        maxValue = Math.max(0, Math.min(1, maxValue));

                        result.delete();
                        if (mask) {
                            mask.delete();
                        }
                        
                        // 更新最佳结果
                        if (maxValue > bestResult.confidence) {
                            bestResult = {
                                found: maxValue >= threshold,
                                confidence: maxValue,
                                location: {
                                    x: maxLoc.x,
                                    y: maxLoc.y,
                                    width: templMat.cols,
                                    height: templMat.rows
                                },
                                index: i,
                            };
                        }
                    } catch (error) {
                        console.error(`处理模板图片 ${i} 时出错:`, error);
                    } finally {
                        if (templGray) templGray.delete();
                    }
                }

                srcGray.delete();

                return bestResult;
            } catch (error) {
                console.error('图像处理出错:', error);
                throw error;
            }
        }
        // 清理资源
        window.addEventListener('beforeunload', function () {
            if (src) src.delete();
            if (dst) dst.delete();
            if (originalSrc) originalSrc.delete();
            if (currentProcessed) currentProcessed.delete();
            if (croppedImage) croppedImage.delete();
            if (largeImageMat) largeImageMat.delete();
            
            // 清理小图Mat对象
            smallImageMats.forEach(mat => {
                if (mat) mat.delete();
            });
        });
    </script>
</body>

</html>